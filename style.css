// 等待整个 DOM 加载完成后再执行脚本
document.addEventListener('DOMContentLoaded', () => {
    
    // --- 1. 初始化设置 (与 Python 脚本对应) ---
    const container = document.querySelector('.guidance-container');
    if (!container) return;

    // 创建 Canvas 元素并添加到容器中
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true }); // willReadFrequently 优化 getImageData
    container.appendChild(canvas);
    canvas.id = 'guidanceCanvas';

    const text = "Guidance";
    const fontStyle = "700 200px Poppins"; // 对应 'Poppins-Bold', size=200

    const COLOR_T2I = { r: 100, g: 180, b: 255 };
    const COLOR_T2V = { r: 200, g: 100, b: 255 };

    // --- 2. 测量文本并设置 Canvas 尺寸 (与 Python 对应) ---
    // 临时设置字体以测量宽度
    ctx.font = fontStyle;
    const textMetrics = ctx.measureText(text);
    
    // 为了精确获取高度，我们需要一个近似值。200px 的字体高度大约是 250px
    const textWidth = Math.ceil(textMetrics.width);
    const textHeight = 250; 
    
    canvas.width = textWidth;
    canvas.height = textHeight;

    // --- 3. 创建 "Guidance" 的蒙版 (复刻 guidance_mask) ---
    // 重新设置字体，因为改变 canvas 尺寸会重置 context
    ctx.font = fontStyle;
    ctx.fillStyle = "#000"; // 用纯色绘制文本以创建蒙版
    ctx.textBaseline = 'middle'; // 垂直居中对齐
    ctx.fillText(text, 0, textHeight / 2);
    
    // 获取像素数据，这等同于 Python 中的 np.array(guidance_mask)
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    const pixelCoords = [];

    // 遍历所有像素，找到属于文本的像素坐标
    // 这等同于 Python 中的 coords = np.where(...)
    for (let y = 0; y < canvas.height; y++) {
        for (let x = 0; x < canvas.width; x++) {
            // 检查 alpha 通道，如果像素不透明，则它是文本的一部分
            // imageData.data 是 [R, G, B, A, R, G, B, A, ...]
            if (data[(y * canvas.width + x) * 4 + 3] > 0) {
                pixelCoords.push({ x, y });
            }
        }
    }

    // --- 4. 清空画布，准备绘制粒子 ---
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // --- 5. 绘制粒子效果 (复刻 particle_layer) ---
    // 这等同于 Python 中的 num_particles = len(coords[0]) // 4
    const numParticles = Math.floor(pixelCoords.length / 4); 

    // 循环绘制每一个粒子
    for (let i = 0; i < numParticles; i++) {
        // 随机从像素坐标中取样，等同于 Python 中的 random.sample
        const p = pixelCoords[Math.floor(Math.random() * pixelCoords.length)];
        
        // 计算颜色渐变，等同于 Python 中的 ratio 和 r,g,b 计算
        const ratio = p.x / canvas.width;
        const r = Math.floor(COLOR_T2I.r * (1 - ratio) + COLOR_T2V.r * ratio);
        const g = Math.floor(COLOR_T2I.g * (1 - ratio) + COLOR_T2V.g * ratio);
        const b = Math.floor(COLOR_T2I.b * (1 - ratio) + COLOR_T2V.b * ratio);

        // 随机大小和亮度 (alpha)，等同于 Python 中的 size 和 brightness
        const size = [1, 2, 2, 3][Math.floor(Math.random() * 4)];
        const brightness = Math.random() * 0.5 + 0.5; // 0.5 to 1.0 (CSS alpha)
        
        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${brightness})`;

        // 绘制粒子 (用圆形代替椭圆，效果类似且更简单)
        // 等同于 Python 中的 particle_draw.ellipse(...)
        ctx.beginPath();
        ctx.arc(p.x, p.y, size / 2, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // --- 6. 添加辉光效果 ---
    // 辉光效果已在 style.css 中通过 filter: drop-shadow() 实现。
    // 这种方法性能更好，因为它由 GPU 加速，且只应用一次。
    // 如果非要在 JS 中实现，可以在绘制粒子前取消 CSS filter 并添加:
    // ctx.shadowColor = 'rgba(200, 200, 255, 0.3)';
    // ctx.shadowBlur = 20;
});
